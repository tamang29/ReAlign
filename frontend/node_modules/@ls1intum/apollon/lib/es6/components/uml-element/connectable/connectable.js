import React, { Component } from 'react';
import { findDOMNode } from 'react-dom';
import { connect } from 'react-redux';
import { Direction } from '../../../services/uml-element/uml-element-port';
import { UMLElementRepository } from '../../../services/uml-element/uml-element-repository';
import { UMLRelationshipRepository } from '../../../services/uml-relationship/uml-relationship-repository';
import { Point } from '../../../utils/geometry/point';
import { styled } from '../../theme/styles';
import { UMLElements } from '../../../packages/uml-elements';
import { UMLRelationships } from '../../../packages/uml-relationships';
import { convertTouchEndIntoPointerUp } from '../../../utils/touch-event';
import isMobile from 'is-mobile';
import { getPortsForElement } from '../../../services/uml-element/uml-element';
const enhance = connect((state, props) => {
    return {
        hovered: state.hovered[0] === props.id,
        selected: state.selected.includes(props.id),
        connecting: !!state.connecting.length,
        reconnecting: !!Object.keys(state.reconnecting).length,
        element: state.elements[props.id],
        type: state.elements[props.id].type,
    };
}, {
    start: UMLElementRepository.startConnecting,
    connect: UMLElementRepository.connect,
    reconnect: UMLRelationshipRepository.reconnect,
});
const Handle = styled((props) => {
    const { alternativePortVisualization, ...otherProps } = props;
    // alternative port visualization size
    const alternativePortHeight = 10;
    const alternativePortWidth = 5;
    const alternativePortCircleSize = 30;
    // default port visualization size
    const defaultPortSize = 20;
    if (alternativePortVisualization) {
        return (React.createElement("svg", { ...otherProps },
            React.createElement("path", { d: `M ${alternativePortWidth / 2} 0 v -${alternativePortHeight} h -${alternativePortWidth} v ${alternativePortHeight} Z` }),
            React.createElement("path", { d: `M -${alternativePortCircleSize / 2} -${alternativePortHeight + alternativePortCircleSize / 2}` +
                    ` a ${alternativePortCircleSize / 2} ${alternativePortCircleSize / 2} 0 0 1 ${alternativePortCircleSize} 0` +
                    ` a ${alternativePortCircleSize / 2} ${alternativePortCircleSize / 2} 0 0 1 -${alternativePortCircleSize} 0` })));
    }
    else {
        return (React.createElement("svg", { ...otherProps },
            React.createElement("path", { d: `M -${defaultPortSize} 0 A ${defaultPortSize / 2} ${defaultPortSize / 2} 0 0 1 ${defaultPortSize} 0` })));
    }
}).attrs(({ direction, ports }) => ({
    fill: '#0064ff',
    fillOpacity: 0.2,
    x: `${ports[direction].x}px`,
    y: `${ports[direction].y}px`,
    rotate: direction === Direction.Up || direction === Direction.Topright || direction === Direction.Topleft
        ? 0
        : direction === Direction.Right || direction === Direction.Upright || direction === Direction.Downright
            ? 90
            : direction === Direction.Down || direction === Direction.Bottomright || direction === Direction.Bottomleft
                ? 180
                : -90,
})) `
  cursor: crosshair;
  pointer-events: all;

  path {
    transform: rotate(${(props) => props.rotate}deg);
  }
`;
export const connectable = (WrappedComponent) => {
    class Connectable extends Component {
        constructor() {
            super(...arguments);
            this.elementOnPointerUp = (event) => {
                const node = findDOMNode(this);
                // create pointer up event in order to follow connection logic
                // created pointer up event has the correct target, (touchend triggered on same element as touchstart)
                // -> connection logic for desktop can be applied
                if (!(event instanceof PointerEvent)) {
                    convertTouchEndIntoPointerUp(event);
                    return;
                }
                let direction;
                // if available, we can get the direction from the event target
                if (event.target instanceof SVGElement &&
                    event.target.parentElement != null &&
                    event.target.parentElement.hasAttribute('direction')) {
                    direction = event.target.parentElement.getAttribute('direction');
                }
                // otherwise get the direction the old way
                if (direction == null) {
                    // calculate event position relative to object position in %
                    const nodeRect = node.getBoundingClientRect();
                    const relEventPosition = {
                        x: (event.clientX - nodeRect.left) / nodeRect.width,
                        y: (event.clientY - nodeRect.top) / nodeRect.height,
                    };
                    // relative port locations in %
                    const relativePortLocation = {
                        [Direction.Up]: new Point(0.5, 0),
                        [Direction.Right]: new Point(1, 0.5),
                        [Direction.Down]: new Point(0.5, 1),
                        [Direction.Left]: new Point(0, 0.5),
                        [Direction.Upright]: new Point(1, 0.25),
                        [Direction.Downright]: new Point(1, 0.75),
                        [Direction.Upleft]: new Point(0, 0.25),
                        [Direction.Downleft]: new Point(0, 0.75),
                        [Direction.Topright]: new Point(0.75, 0),
                        [Direction.Bottomright]: new Point(0.75, 1),
                        [Direction.Topleft]: new Point(0.25, 0),
                        [Direction.Bottomleft]: new Point(0.25, 1),
                    };
                    const ports = getPortsForElement(this.props.element);
                    // calculate the distances to all handles
                    const distances = Object.entries(ports).map(([key, value]) => ({
                        key,
                        distance: Math.sqrt(Math.pow(relativePortLocation[key].x - relEventPosition.x, 2) +
                            Math.pow(relativePortLocation[key].y - relEventPosition.y, 2)),
                    }));
                    // use handle with min distance to connect to
                    const minDistance = Math.min(...distances.map((value) => value.distance));
                    direction = distances.filter((value) => minDistance === value.distance)[0].key;
                }
                if (this.props.connecting) {
                    this.props.connect({ element: this.props.id, direction });
                }
                if (this.props.reconnecting && !event.defaultPrevented) {
                    this.props.reconnect({ element: this.props.id, direction });
                    event.preventDefault();
                }
            };
            this.onPointerDown = (event) => {
                const direction = event.currentTarget.getAttribute('direction');
                const id = event.currentTarget.parentElement.getAttribute('id');
                this.props.start(direction, id);
            };
            this.onPointerUp = (event) => {
                const direction = event.currentTarget.getAttribute('direction');
                if (this.props.connecting) {
                    this.props.connect({ element: this.props.id, direction });
                }
                if (this.props.reconnecting) {
                    this.props.reconnect({ element: this.props.id, direction });
                }
            };
        }
        componentDidMount() {
            const node = findDOMNode(this);
            node.addEventListener('pointerup', this.elementOnPointerUp.bind(this));
            if (isMobile({ tablet: true })) {
                node.addEventListener('touchend', this.elementOnPointerUp.bind(this));
            }
        }
        componentWillUnmount() {
            const node = findDOMNode(this);
            node.removeEventListener('pointerup', this.elementOnPointerUp);
            if (isMobile({ tablet: true })) {
                node.removeEventListener('touchend', this.elementOnPointerUp);
            }
        }
        render() {
            const { hovered, selected, connecting, reconnecting, start, connect: _, reconnect, type, element, ...props } = this.props;
            const features = { ...UMLElements, ...UMLRelationships }[type].features;
            const ports = getPortsForElement(element);
            return (React.createElement(WrappedComponent, { ...props },
                props.children,
                (hovered || selected || connecting || reconnecting) && (React.createElement(React.Fragment, null,
                    this.props.type !== 'ActivityForkNode' && (React.createElement(Handle, { ports: ports, direction: Direction.Up, onPointerDown: this.onPointerDown, onPointerUp: this.onPointerUp, alternativePortVisualization: features.alternativePortVisualization })),
                    this.props.type !== 'ActivityForkNodeHorizontal' && (React.createElement(Handle, { ports: ports, direction: Direction.Right, onPointerDown: this.onPointerDown, onPointerUp: this.onPointerUp, alternativePortVisualization: features.alternativePortVisualization })),
                    this.props.type !== 'ActivityForkNode' && (React.createElement(Handle, { ports: ports, direction: Direction.Down, onPointerDown: this.onPointerDown, onPointerUp: this.onPointerUp, alternativePortVisualization: features.alternativePortVisualization })),
                    this.props.type !== 'ActivityForkNodeHorizontal' && (React.createElement(Handle, { ports: ports, direction: Direction.Left, onPointerDown: this.onPointerDown, onPointerUp: this.onPointerUp, alternativePortVisualization: features.alternativePortVisualization })),
                    this.props.type === 'ActivityForkNode' && this.props.element.bounds.height > 120 && (React.createElement(React.Fragment, null,
                        React.createElement(Handle, { ports: ports, direction: Direction.Upright, onPointerDown: this.onPointerDown, onPointerUp: this.onPointerUp, alternativePortVisualization: features.alternativePortVisualization }),
                        React.createElement(Handle, { ports: ports, direction: Direction.Upleft, onPointerDown: this.onPointerDown, onPointerUp: this.onPointerUp, alternativePortVisualization: features.alternativePortVisualization }),
                        React.createElement(Handle, { ports: ports, direction: Direction.Downright, onPointerDown: this.onPointerDown, onPointerUp: this.onPointerUp, alternativePortVisualization: features.alternativePortVisualization }),
                        React.createElement(Handle, { ports: ports, direction: Direction.Downleft, onPointerDown: this.onPointerDown, onPointerUp: this.onPointerUp, alternativePortVisualization: features.alternativePortVisualization }))),
                    this.props.type === 'ActivityForkNodeHorizontal' && this.props.element.bounds.width > 120 && (React.createElement(React.Fragment, null,
                        React.createElement(Handle, { ports: ports, direction: Direction.Topright, onPointerDown: this.onPointerDown, onPointerUp: this.onPointerUp, alternativePortVisualization: features.alternativePortVisualization }),
                        React.createElement(Handle, { ports: ports, direction: Direction.Topleft, onPointerDown: this.onPointerDown, onPointerUp: this.onPointerUp, alternativePortVisualization: features.alternativePortVisualization }),
                        React.createElement(Handle, { ports: ports, direction: Direction.Bottomright, onPointerDown: this.onPointerDown, onPointerUp: this.onPointerUp, alternativePortVisualization: features.alternativePortVisualization }),
                        React.createElement(Handle, { ports: ports, direction: Direction.Bottomleft, onPointerDown: this.onPointerDown, onPointerUp: this.onPointerUp, alternativePortVisualization: features.alternativePortVisualization })))))));
        }
    }
    return enhance(Connectable);
};
//# sourceMappingURL=connectable.js.map