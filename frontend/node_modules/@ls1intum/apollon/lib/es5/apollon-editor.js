"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApollonEditor = void 0;
var tslib_1 = require("tslib");
require("pepjs");
var react_1 = require("react");
var client_1 = require("react-dom/client");
var model_state_1 = require("./components/store/model-state");
var uml_element_type_1 = require("./packages/uml-element-type");
var uml_relationship_type_1 = require("./packages/uml-relationship-type");
var application_1 = require("./scenes/application");
var svg_1 = require("./scenes/svg");
var patcher_1 = require("./services/patcher");
var editor_types_1 = require("./services/editor/editor-types");
var uml_diagram_1 = require("./services/uml-diagram/uml-diagram");
var uml_element_repository_1 = require("./services/uml-element/uml-element-repository");
var debounce_1 = require("./utils/debounce");
var delay_1 = require("./utils/delay");
var ErrorBoundary_1 = require("./components/controls/error-boundary/ErrorBoundary");
var replace_color_variables_1 = require("./utils/replace-color-variables");
var ApollonEditor = /** @class */ (function () {
    function ApollonEditor(container, options) {
        var _this = this;
        var _a;
        this.container = container;
        this.options = options;
        this.selection = { elements: {}, relationships: {} };
        this.assessments = [];
        this.application = null;
        this.patcher = new patcher_1.Patcher();
        this.selectionSubscribers = {};
        this.assessmentSubscribers = {};
        this.modelSubscribers = {};
        this.discreteModelSubscribers = {};
        this.errorSubscribers = {};
        this.componentDidMount = function () {
            _this.container.setAttribute('touch-action', 'none');
        };
        /**
         * Triggered whenever an action is dispatched which potentially lead to a change in the store / state tree
         * Used to notify all the selection and assessment subscribers of Apollon
         */
        this.onDispatch = function () {
            if (!_this.store)
                return;
            var _a = _this.store.getState(), elements = _a.elements, selected = _a.selected, assessments = _a.assessments;
            var selection = {
                elements: selected
                    .filter(function (id) { return elements[id].type in uml_element_type_1.UMLElementType; })
                    .reduce(function (acc, id) {
                    var _a;
                    return (tslib_1.__assign(tslib_1.__assign({}, acc), (_a = {}, _a[id] = true, _a)));
                }, {}),
                relationships: selected
                    .filter(function (id) { return elements[id].type in uml_relationship_type_1.UMLRelationshipType; })
                    .reduce(function (acc, id) {
                    var _a;
                    return (tslib_1.__assign(tslib_1.__assign({}, acc), (_a = {}, _a[id] = true, _a)));
                }, {}),
            };
            // check if previous selection differs from current selection, if yes -> notify subscribers
            if (JSON.stringify(_this.selection) !== JSON.stringify(selection)) {
                Object.values(_this.selectionSubscribers).forEach(function (subscriber) { return subscriber(selection); });
                _this.selection = selection;
            }
            var umlAssessments = Object.keys(assessments).map(function (id) { return ({
                modelElementId: id,
                elementType: elements[id].type,
                score: assessments[id].score,
                feedback: assessments[id].feedback,
                dropInfo: assessments[id].dropInfo,
            }); });
            // check if previous assessment differs from current selection, if yes -> notify subscribers
            if (JSON.stringify(_this.assessments) !== JSON.stringify(umlAssessments)) {
                Object.values(_this.assessmentSubscribers).forEach(function (subscriber) { return subscriber(umlAssessments); });
                _this.assessments = umlAssessments;
            }
            // notfiy that action was done
            _this.notifyModelSubscribers();
            _this.notifyDiscreteModelSubscribers();
        };
        /**
         * Triggered whenever an action is dispatched which potentially lead to a change in the store / state tree
         * Used to notify all the selection and assessment subscribers of Apollon if the action ends with END or DELETE
         */
        this.notifyDiscreteModelSubscribers = function () {
            try {
                // if state not available -> do not emit changes
                if (!_this.store)
                    return;
                var model = _this.model;
                if (
                // At the end of each update operation there is an action that ends with END except DELETE
                // Function is called with every redux action but only notifies subscribers if the action ends with given words
                _this.store.getState().lastAction.endsWith('END') ||
                    _this.store.getState().lastAction.endsWith('DELETE')) {
                    var lastModel_1 = model_state_1.ModelState.toModel(_this.store.getState());
                    Object.values(_this.discreteModelSubscribers).forEach(function (subscriber) { return subscriber(lastModel_1); });
                }
            }
            catch (error) {
                // if error occured while getting current state for subscribers -> do not emit changes
                // -> no need to emit latest changes
            }
        };
        this.notifyModelSubscribers = (0, debounce_1.debounce)(function () {
            try {
                // if state not available -> do not emit changes
                if (!_this.store)
                    return;
                var model_1 = _this.model;
                var lastModel = _this.currentModelState ? model_state_1.ModelState.toModel(_this.currentModelState) : null;
                if ((!lastModel && model_1) || (lastModel && JSON.stringify(model_1) !== JSON.stringify(lastModel))) {
                    Object.values(_this.modelSubscribers).forEach(function (subscriber) { return subscriber(model_1); });
                    _this.currentModelState = _this.store.getState();
                }
                else {
                    _this.currentModelState = _this.store.getState();
                }
            }
            catch (error) {
                // if error occured while getting current state for subscribers -> do not emit changes
                // -> no need to emit latest changes
            }
        }, 50);
        var state = options.model ? model_state_1.ModelState.fromModel(options.model) : {};
        state = tslib_1.__assign(tslib_1.__assign({}, state), { diagram: new uml_diagram_1.UMLDiagram(tslib_1.__assign(tslib_1.__assign({}, state.diagram), { type: options.type })), editor: tslib_1.__assign(tslib_1.__assign({}, state.editor), { view: "Modelling" /* ApollonView.Modelling */, mode: options.mode || editor_types_1.ApollonMode.Exporting, colorEnabled: options.colorEnabled || false, zoomFactor: options.scale || 1.0, readonly: options.readonly || false, enablePopups: options.enablePopups === true || options.enablePopups === undefined, enableCopyPasteToClipboard: options.copyPasteToClipboard === true, features: {
                    hoverable: true,
                    selectable: true,
                    movable: !options.readonly,
                    resizable: !options.readonly,
                    connectable: !options.readonly,
                    updatable: !options.readonly,
                    droppable: !options.readonly,
                    alternativePortVisualization: false,
                } }) });
        var nextRenderResolve;
        this.nextRenderPromise = new Promise(function (resolve) {
            nextRenderResolve = resolve;
        });
        var element = (0, react_1.createElement)(application_1.Application, {
            ref: function (app) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (app == null)
                                return [2 /*return*/];
                            this.application = app;
                            return [4 /*yield*/, app.initialized];
                        case 1:
                            _a.sent();
                            this.store.subscribe(this.onDispatch);
                            nextRenderResolve();
                            return [2 /*return*/];
                    }
                });
            }); },
            state: state,
            patcher: this.patcher,
            styles: options.theme,
            locale: options.locale,
        });
        var errorBoundary = (0, react_1.createElement)(ErrorBoundary_1.ErrorBoundary, { onError: this.onErrorOccurred.bind(this) }, element);
        this.root = (0, client_1.createRoot)(container);
        this.root.render(errorBoundary);
        try {
            this.currentModelState = (_a = this.store) === null || _a === void 0 ? void 0 : _a.getState();
        }
        catch (error) {
            this.currentModelState = undefined;
        }
        this.componentDidMount();
    }
    ApollonEditor.prototype.ensureInitialized = function () {
        if (!this.store) {
            // tslint:disable-next-line:no-console
            console.error('The application state of Apollon could not be retrieved. The editor may already be destroyed or you might need to `await apollonEditor.nextRender`.');
            throw new Error('The application state of Apollon could not be retrieved. The editor may already be destroyed or you might need to `await apollonEditor.nextRender`.');
        }
    };
    Object.defineProperty(ApollonEditor.prototype, "model", {
        /**
         * Returns the current model of the Apollon Editor
         */
        get: function () {
            this.ensureInitialized();
            return model_state_1.ModelState.toModel(this.store.getState());
        },
        /**
         * Sets a model as the current model of the Apollon Editor
         * @param model valid Apollon Editor Model
         */
        set: function (model) {
            this.ensureInitialized();
            var state = tslib_1.__assign(tslib_1.__assign({}, model_state_1.ModelState.fromModel(model)), { editor: tslib_1.__assign({}, this.store.getState().editor) });
            this.recreateEditor(state);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ApollonEditor.prototype, "type", {
        /**
         * Sets the diagram type of the current Apollon Editor. This changes the selection of elements the user can chose from on the sidebar.
         * @param diagramType the new diagram type
         */
        set: function (diagramType) {
            this.ensureInitialized();
            var state = tslib_1.__assign(tslib_1.__assign({}, this.store.getState()), { diagram: new uml_diagram_1.UMLDiagram({
                    type: diagramType,
                }), elements: undefined });
            this.recreateEditor(state);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ApollonEditor.prototype, "locale", {
        /**
         * Sets the current locale of the Apollon Editor.
         * @param locale supported locale
         */
        set: function (locale) {
            this.ensureInitialized();
            var state = this.store.getState();
            this.options.locale = locale;
            this.recreateEditor(state);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * renders a model as a svg and returns it. Therefore the svg is temporarily added to the dom and removed after it has been rendered.
     * @param model the apollon model to export as a svg
     * @param options options to change the export behavior (add margin, exclude element ...)
     * @param theme the theme which should be applied on the svg
     */
    ApollonEditor.exportModelAsSvg = function (model, options, theme) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var container, root, element, svg;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        container = document.createElement('div');
                        root = (0, client_1.createRoot)(container);
                        element = (0, react_1.createElement)(svg_1.Svg, { model: model, options: options, styles: theme });
                        svg = new svg_1.Svg({ model: model, options: options, styles: theme });
                        root.render(element);
                        return [4 /*yield*/, (0, delay_1.delay)(50)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, {
                                svg: (0, replace_color_variables_1.replaceColorVariables)(container.querySelector('svg').outerHTML),
                                clip: svg.state.bounds,
                            }];
                }
            });
        });
    };
    /**
     * Destroys the Apollon Editor and unmounts it from its container
     */
    ApollonEditor.prototype.destroy = function () {
        var _a;
        (_a = this.root) === null || _a === void 0 ? void 0 : _a.unmount();
    };
    /**
     * Selects the by their id identified UMLElements and UMLRelationships
     * @param selection contains ids of the elements and relationships which should be selected
     */
    ApollonEditor.prototype.select = function (selection) {
        if (!this.store)
            return;
        var dispatch = this.store.dispatch;
        dispatch(uml_element_repository_1.UMLElementRepository.deselect());
        dispatch(uml_element_repository_1.UMLElementRepository.select(tslib_1.__spreadArray(tslib_1.__spreadArray([], tslib_1.__read(Object.entries(selection.elements)
            .filter(function (_a) {
            var _b = tslib_1.__read(_a, 2), selected = _b[1];
            return selected;
        })
            .map(function (_a) {
            var _b = tslib_1.__read(_a, 1), id = _b[0];
            return id;
        })), false), tslib_1.__read(Object.entries(selection.relationships)
            .filter(function (_a) {
            var _b = tslib_1.__read(_a, 2), selected = _b[1];
            return selected;
        })
            .map(function (_a) {
            var _b = tslib_1.__read(_a, 1), id = _b[0];
            return id;
        })), false)));
    };
    ApollonEditor.prototype._getNewSubscriptionId = function (subscribers) {
        // largest key + 1
        if (Object.keys(subscribers).length === 0)
            return 0;
        return Math.max.apply(Math, tslib_1.__spreadArray([], tslib_1.__read(Object.keys(subscribers).map(function (key) { return parseInt(key); })), false)) + 1; // tslint:disable-line
    };
    /**
     * Register callback which is executed when the selection of elements and relationships changes
     * @param callback function which is called when selection changes
     * @return returns the subscription identifier which can be used to unsubscribe
     */
    ApollonEditor.prototype.subscribeToSelectionChange = function (callback) {
        var id = this._getNewSubscriptionId(this.selectionSubscribers);
        this.selectionSubscribers[id] = callback;
        return id;
    };
    /**
     * Remove selection subscription, so that the corresponding callback is no longer executed when the selection of elements is changed.
     * @param subscriptionId subscription identifier
     */
    ApollonEditor.prototype.unsubscribeFromSelectionChange = function (subscriptionId) {
        delete this.selectionSubscribers[subscriptionId];
    };
    /**
     * Register callback which is executed when the assessment of elements and relationships are changed
     * @param callback function which is called when assessment changes
     * @return returns the subscription identifier which can be used to unsubscribe
     */
    ApollonEditor.prototype.subscribeToAssessmentChange = function (callback) {
        var id = this._getNewSubscriptionId(this.assessmentSubscribers);
        this.assessmentSubscribers[id] = callback;
        return id;
    };
    /**
     * Remove assessment subscription, so that the corresponding callback is no longer executed when the assessment of elements are changed.
     * @param subscriptionId subscription identifier
     */
    ApollonEditor.prototype.unsubscribeFromAssessmentChange = function (subscriptionId) {
        delete this.assessmentSubscribers[subscriptionId];
    };
    /**
     * Register callback which is executed when the model changes
     * @param callback function which is called when the model changes
     * @return returns the subscription identifier which can be used to unsubscribe
     */
    ApollonEditor.prototype.subscribeToModelChange = function (callback) {
        var id = this._getNewSubscriptionId(this.modelSubscribers);
        this.modelSubscribers[id] = callback;
        return id;
    };
    /**
     * Remove assessment subscription, so that the corresponding callback is no longer executed when the assessment of elements are changed.
     * @param subscriptionId subscription identifier
     */
    ApollonEditor.prototype.unsubscribeFromModelChange = function (subscriptionId) {
        delete this.modelSubscribers[subscriptionId];
    };
    /**
     * Register callback which is executed at the end of each user action and ignores the changes during a user action
     * For example: moving of an element is ignored until user releases the element
     * @param callback function which is called when the model changes
     * @return returns the subscription identifier which can be used to unsubscribe
     */
    ApollonEditor.prototype.subscribeToModelDiscreteChange = function (callback) {
        var id = this._getNewSubscriptionId(this.discreteModelSubscribers);
        this.discreteModelSubscribers[id] = callback;
        return id;
    };
    /**
     * Remove model change subscription, so that the corresponding callback is no longer executed when the model is changed.
     * @param subscriptionId subscription identifier
     */
    ApollonEditor.prototype.unsubscribeFromDiscreteModelChange = function (subscriptionId) {
        delete this.discreteModelSubscribers[subscriptionId];
    };
    /**
     * Register callback which is executed when the model changes, receiving the changes to the model
     * in [JSONPatch](http://jsonpatch.com/) format. This callback is only executed for discrete changes to the model.
     * Discrete changes are changes that should not be missed and are executed at the end of important user actions.
     * @param callback function which is called when the model changes
     * @returns the subscription identifier which can be used to unsubscribe
     */
    ApollonEditor.prototype.subscribeToModelChangePatches = function (callback) {
        return this.patcher.subscribeToDiscreteChanges(callback);
    };
    /**
     * Registers a callback which is executed when the model changes, receiving the changes to the model
     * in [JSONPatch](http://jsonpatch.com/) format. This callback is executed for every change to the model, including
     * discrete and continuous changes. Discrete changes are changes that should not be missed and are executed at
     * the end of important user actions. Continuous changes are changes that are executed during user actions, and is
     * ok to miss some of them. For example: moving of an element is a continuous change, while releasing the element
     * is a discrete change.
     * @param callback function which is called when the model changes
     * @returns the subscription identifier which can be used to unsubscribe using `unsubscribeFromModelChangePatches()`.
     */
    ApollonEditor.prototype.subscribeToAllModelChangePatches = function (callback) {
        return this.patcher.subscribe(callback);
    };
    /**
     * Registers a callback which is executed when the model changes, receiving only the continuous changes to the model.
     * Continuous changes are changes that are executed during user actions, and is ok to miss some of them. For example:
     * moving of an element is a continuous change, while releasing the element is a discrete change.
     *
     * **IMPORTANT**: If you want to keep proper track of the model, make sure that you subscribe to discrete changes
     * as well, either via `subscribeToModelChangePatches()` or `subscribeToAllModelChangePatches()`.
     *
     * @param callback function which is called when the model changes
     * @returns the subscription identifier which can be used to unsubscribe using `unsubscribeFromModelChangePatches()`.
     */
    ApollonEditor.prototype.subscribeToModelContinuousChangePatches = function (callback) {
        return this.patcher.subscribeToContinuousChanges(callback);
    };
    /**
     * Remove model change subscription, so that the corresponding callback is no longer executed when the model is changed.
     * @param subscriptionId subscription identifier
     */
    ApollonEditor.prototype.unsubscribeFromModelChangePatches = function (subscriptionId) {
        return this.patcher.unsubscribe(subscriptionId);
    };
    /**
     * Imports a patch into the current model.
     * @param patch changes to be applied to the model, in [JSONPatch](http://jsonpatch.com/) format.
     */
    ApollonEditor.prototype.importPatch = function (patch) {
        var _a;
        (_a = this.store) === null || _a === void 0 ? void 0 : _a.dispatch(patcher_1.PatcherRepository.patch(patch));
    };
    /**
     * Register callback which is executed when an error occurs in the editor. Apollon will try to recreate the latest working state when an error occurs, so that it is less visible to user / less interrupting.
     * A registered callback would be called anyway, giving the full error, so that the application which uses Apollon can decide what to do next.
     * @param callback callback function which is called when an error occurs
     * @return returns the subscription identifier which can be used to unsubscribe
     */
    ApollonEditor.prototype.subscribeToApollonErrors = function (callback) {
        var id = this._getNewSubscriptionId(this.errorSubscribers);
        this.errorSubscribers[id] = callback;
        return id;
    };
    /**
     * Displays given elements and relationships as selected or deselected by
     * a given remote selector, identified by a name and a color.
     * @param selectorName name of the remote selector
     * @param selectorColor color of the remote selector
     * @param select ids of elements and relationships to be selected
     * @param deselect ids of elements and relationships to be deselected
     */
    ApollonEditor.prototype.remoteSelect = function (selectorName, selectorColor, select, deselect) {
        var _a;
        (_a = this.store) === null || _a === void 0 ? void 0 : _a.dispatch(uml_element_repository_1.UMLElementRepository.remoteSelectDeselect({ name: selectorName, color: selectorColor }, select, deselect || []));
    };
    /**
     * Allows a given set of remote selectors for remotely selecting and deselecting
     * elements and relationships, removing all other selectors. This won't have an effect
     * on future remote selections.
     * @param allowedSelectors allowed remote selectors
     */
    ApollonEditor.prototype.pruneRemoteSelectors = function (allowedSelectors) {
        var _a;
        (_a = this.store) === null || _a === void 0 ? void 0 : _a.dispatch(uml_element_repository_1.UMLElementRepository.pruneRemoteSelectors(allowedSelectors));
    };
    /**
     * Removes error subscription, so that the corresponding callback is no longer executed when an error occurs.
     * @param subscriptionId subscription identifier
     */
    ApollonEditor.prototype.unsubscribeToApollonErrors = function (subscriptionId) {
        delete this.errorSubscribers[subscriptionId];
    };
    /**
     * exports current model as svg
     * @param options options to change the export behavior (add margin, exclude element ...)
     */
    ApollonEditor.prototype.exportAsSVG = function (options) {
        return ApollonEditor.exportModelAsSvg(this.model, options, this.options.theme);
    };
    /**
     * Returns current scale factor of the application
     */
    ApollonEditor.prototype.getScaleFactor = function () {
        return this.options.scale || 1;
    };
    ApollonEditor.prototype.recreateEditor = function (state) {
        var _this = this;
        this.destroy();
        var nextRenderResolve;
        this.nextRenderPromise = new Promise(function (resolve) {
            nextRenderResolve = resolve;
        });
        var element = (0, react_1.createElement)(application_1.Application, {
            ref: function (app) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (app == null)
                                return [2 /*return*/];
                            this.application = app;
                            return [4 /*yield*/, app.initialized];
                        case 1:
                            _a.sent();
                            this.store.subscribe(this.onDispatch);
                            nextRenderResolve();
                            return [2 /*return*/];
                    }
                });
            }); },
            state: state,
            styles: this.options.theme,
            locale: this.options.locale,
        });
        var errorBoundary = (0, react_1.createElement)(ErrorBoundary_1.ErrorBoundary, { onError: this.onErrorOccurred.bind(this) }, element);
        this.root = (0, client_1.createRoot)(this.container);
        this.root.render(errorBoundary);
        this.componentDidMount();
    };
    ApollonEditor.prototype.onErrorOccurred = function (error) {
        Object.values(this.errorSubscribers).forEach(function (subscriber) { return subscriber(error); });
        this.restoreEditor();
    };
    ApollonEditor.prototype.restoreEditor = function () {
        if (this.currentModelState) {
            var state = tslib_1.__assign(tslib_1.__assign({}, this.currentModelState), { hovered: [], selected: [], moving: [], resizing: [], connecting: [], reconnecting: {}, updating: [] });
            this.recreateEditor(state);
        }
    };
    Object.defineProperty(ApollonEditor.prototype, "store", {
        get: function () {
            var _a, _b;
            return (_b = (_a = this.application) === null || _a === void 0 ? void 0 : _a.store) === null || _b === void 0 ? void 0 : _b.state.store;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ApollonEditor.prototype, "nextRender", {
        /**
         * Returns a Promise that resolves when the current React render cycle is finished.
         * => this.store is be available and there should be no errors when trying to access some methods like this.model
         */
        get: function () {
            return this.nextRenderPromise;
        },
        enumerable: false,
        configurable: true
    });
    return ApollonEditor;
}());
exports.ApollonEditor = ApollonEditor;
//# sourceMappingURL=apollon-editor.js.map