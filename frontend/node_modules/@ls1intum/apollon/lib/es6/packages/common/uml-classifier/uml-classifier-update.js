import React, { Component, createRef } from 'react';
import { connect } from 'react-redux';
import { compose } from 'redux';
import styled from 'styled-components';
import { Button } from '../../../components/controls/button/button';
import { ColorButton } from '../../../components/controls/color-button/color-button';
import { Divider } from '../../../components/controls/divider/divider';
import { TrashIcon } from '../../../components/controls/icon/trash';
import { Switch } from '../../../components/controls/switch/switch';
import { Textfield } from '../../../components/controls/textfield/textfield';
import { Header } from '../../../components/controls/typography/typography';
import { localized } from '../../../components/i18n/localized';
import { StylePane } from '../../../components/style-pane/style-pane';
import { UMLElementRepository } from '../../../services/uml-element/uml-element-repository';
import { notEmpty } from '../../../utils/not-empty';
import { ClassElementType } from '../../uml-class-diagram';
import { UMLClassAttribute } from '../../uml-class-diagram/uml-class-attribute/uml-class-attribute';
import { UMLClassMethod } from '../../uml-class-diagram/uml-class-method/uml-class-method';
import { UMLElements } from '../../uml-elements';
import UmlAttributeUpdate from './uml-classifier-attribute-update';
const Flex = styled.div `
  display: flex;
  align-items: baseline;
  justify-content: space-between;
`;
const enhance = compose(localized, connect(null, {
    create: UMLElementRepository.create,
    update: UMLElementRepository.update,
    delete: UMLElementRepository.delete,
    getById: UMLElementRepository.getById,
}));
const getInitialState = () => ({
    fieldToFocus: undefined,
    colorOpen: false,
});
class ClassifierUpdate extends Component {
    constructor() {
        super(...arguments);
        this.state = getInitialState();
        this.newMethodField = createRef();
        this.newAttributeField = createRef();
        this.toggleColor = () => {
            this.setState((state) => ({
                colorOpen: !state.colorOpen,
            }));
        };
        this.create = (Clazz) => (value) => {
            const { element, create } = this.props;
            const member = new Clazz();
            member.name = value;
            create(member, element.id);
        };
        this.rename = (id) => (value) => {
            this.props.update(id, { name: value });
        };
        this.toggle = (type) => {
            const { element, update } = this.props;
            const newType = element.type === type ? ClassElementType.Class : type;
            const instance = new UMLElements[newType]({
                id: element.id,
                name: element.name,
                type: element.type,
                owner: element.owner,
                bounds: element.bounds,
                ownedElements: element.ownedElements,
            });
            update(element.id, instance);
        };
        this.delete = (id) => () => {
            this.props.delete(id);
        };
    }
    componentDidUpdate(prevProps, prevState, snapshot) {
        if (this.state.fieldToFocus) {
            this.state.fieldToFocus.focus();
            this.setState({ fieldToFocus: undefined });
        }
    }
    render() {
        const { element, getById } = this.props;
        const children = element.ownedElements.map((id) => getById(id)).filter(notEmpty);
        const attributes = children.filter((child) => child instanceof UMLClassAttribute);
        const methods = children.filter((child) => child instanceof UMLClassMethod);
        const attributeRefs = [];
        const methodRefs = [];
        return (React.createElement("div", null,
            React.createElement("section", null,
                React.createElement(Flex, null,
                    React.createElement(Textfield, { value: element.name, onChange: this.rename(element.id), autoFocus: true }),
                    React.createElement(ColorButton, { onClick: this.toggleColor }),
                    React.createElement(Button, { color: "link", tabIndex: -1, onClick: this.delete(element.id) },
                        React.createElement(TrashIcon, null))),
                React.createElement(StylePane, { open: this.state.colorOpen, element: element, onColorChange: this.props.update, fillColor: true, lineColor: true, textColor: true }),
                React.createElement(Divider, null)),
            React.createElement("section", null,
                React.createElement(Switch, { value: element.type, onChange: this.toggle, color: "primary" },
                    React.createElement(Switch.Item, { value: ClassElementType.AbstractClass }, this.props.translate('packages.ClassDiagram.AbstractClass')),
                    React.createElement(Switch.Item, { value: ClassElementType.Interface }, this.props.translate('packages.ClassDiagram.Interface')),
                    React.createElement(Switch.Item, { value: ClassElementType.Enumeration }, this.props.translate('packages.ClassDiagram.Enumeration'))),
                React.createElement(Divider, null)),
            React.createElement("section", null,
                React.createElement(Header, null, this.props.translate('popup.attributes')),
                attributes.map((attribute, index) => (React.createElement(UmlAttributeUpdate, { id: attribute.id, key: attribute.id, value: attribute.name, onChange: this.props.update, onSubmitKeyUp: () => index === attributes.length - 1
                        ? this.newAttributeField.current?.focus()
                        : this.setState({
                            fieldToFocus: attributeRefs[index + 1],
                        }), onDelete: this.delete, onRefChange: (ref) => (attributeRefs[index] = ref), element: attribute }))),
                React.createElement(Textfield, { ref: this.newAttributeField, outline: true, value: "", onSubmit: this.create(UMLClassAttribute), onSubmitKeyUp: (key, value) => {
                        // if we have a value -> navigate to next field in case we want to create a new element
                        if (value) {
                            this.setState({
                                fieldToFocus: this.newAttributeField.current,
                            });
                        }
                        else {
                            // if we submit with empty value -> focus next element (either next method field or newMethodfield)
                            if (methodRefs && methodRefs.length > 0) {
                                this.setState({
                                    fieldToFocus: methodRefs[0],
                                });
                            }
                            else {
                                this.setState({
                                    fieldToFocus: this.newMethodField.current,
                                });
                            }
                        }
                    }, onKeyDown: (event) => {
                        // workaround when 'tab' key is pressed:
                        // prevent default and execute blur manually without switching to next tab index
                        // then set focus to newAttributeField field again (componentDidUpdate)
                        if (event.key === 'Tab' && event.currentTarget.value) {
                            event.preventDefault();
                            event.currentTarget.blur();
                            this.setState({
                                fieldToFocus: this.newAttributeField.current,
                            });
                        }
                    } })),
            React.createElement("section", null,
                React.createElement(Divider, null),
                React.createElement(Header, null, this.props.translate('popup.methods')),
                methods.map((method, index) => (React.createElement(UmlAttributeUpdate, { id: method.id, key: method.id, value: method.name, onChange: this.props.update, onSubmitKeyUp: () => index === methods.length - 1
                        ? this.newMethodField.current?.focus()
                        : this.setState({
                            fieldToFocus: methodRefs[index + 1],
                        }), onDelete: this.delete, onRefChange: (ref) => (methodRefs[index] = ref), element: method }))),
                React.createElement(Textfield, { ref: this.newMethodField, outline: true, value: "", onSubmit: this.create(UMLClassMethod), onSubmitKeyUp: () => this.setState({
                        fieldToFocus: this.newMethodField.current,
                    }), onKeyDown: (event) => {
                        // workaround when 'tab' key is pressed:
                        // prevent default and execute blur manually without switching to next tab index
                        // then set focus to newMethodField field again (componentDidUpdate)
                        if (event.key === 'Tab' && event.currentTarget.value) {
                            event.preventDefault();
                            event.currentTarget.blur();
                            this.setState({
                                fieldToFocus: this.newMethodField.current,
                            });
                        }
                    } }))));
    }
}
export const UMLClassifierUpdate = enhance(ClassifierUpdate);
//# sourceMappingURL=uml-classifier-update.js.map